# Verseの関数

- アクションを評価し、指定した入力に基づいて異なる出力を生み出す、再利用可能なコード
  - ただし、関数型プログラミングでは、入力と出力は必ず同じ対になることが望ましい(参照透明性)
- コードの他の部分に関係しない、確認が必要ない実装の詳細が隠される→抽象化

## 関数の宣言

- 関数名、入力(パラメータ、引数)、出力(結果、戻り値)、指定子を使って宣言する
- 関数の本体は、コードブロックで定義する

### 関数宣言の構文

```Verse
関数名<指定子>(引数: 型, ?名前付き引数: 型, ?名前付き引数: 型 = 省略時の値)<指定子> : 結果の型 = { 本体 }

...(... ?名前付き引数: 型)...

...(..., ?名前付き引数: 型 = 省略時の値)...
```

### パラメータ

- 関数の宣言で指定する、入力変数のこと
- 関数の本体で使用する
- パラメータがない場合がある(その際は、 `関数名()` と宣言する)
- 基本的に、パラメータ名と型のペアで定義する
  - たまに、型だけ宣言している場合がある(後述)
- 複数のパラメータで宣言する場合はカンマで区切る

### 結果

- 関数が呼び出されたときの出力
- 宣言時の型は、正常に評価されたときの結果の型を示す
- 結果が必要ないときは `void` 型を指定する
  - 常に `false` を返す

### 本体

- コードブロックで示した内容
- 最後に評価された値が結果となる
- 下記のコードの場合、`SampleFunction` 関数の結果は以下の通り
  - `X` の値が正のときは `100` を返す
  - `X` の値がゼロもしくは負のときは `200` を返す

```Verse
SampleFunction(X: int): int =
  if (X > 0):
    100
  else:
    200
```

- 特定の値を結果として強制的に返すときは `return` キーワードを使う
  - `return` の次に、返したい値を記述する
  - `void` を返す式のときは `return` のみで記述すできる
- `return` キーワードが評価された時点で、呼び出し元に戻る
- 以下の例では、 `BePositive` 関数の引数が正の数のときは `100` を返すが、そうでないときは失敗する
  - `<decides>` 指定子に関しては次節の「[エフェクト](#エフェクト)」を参照
  - `false?` は、強制的に失敗することを示している。
    - そのため、`X > 0` のときは `false?` まで行かせないために、 `return` を使用して強制的に戻るようにしている

```Verse
BePositive(X: int)<decides>: int =
  if (X > 0):
    return 100
  false?
```

### エフェクト

- 関数が呼び出されたときに選択できる追加の動作
- 前節の `<decides>` エフェクトは、「呼び出し元に失敗することを伝播する」ことを指定している
  - 呼び出し元では、失敗したときの処理を実装できる

## 関数の呼び出し

- 関数を評価するための**式**
- 呼び出し方は2種類

### 必ず成功する呼び出し構文

```Verse
関数名(引数)
```

- 必ず成功する(`<decides>`エフェクトが与えられていない)関数を呼び出すときは丸括弧を使う

### 失敗することがある呼び出し構文

```Verse
関数名[引数]
```

- `<decides>` 修飾子を付けた関数を呼び出すときには角括弧を使う
- 以下の例の場合、 `Hoge` 関数の引数が正数のときは `100` を返し、ゼロか負数のときは　`-1` を返す

```Verse
BePositive(X: int)<decides>: int =
  if (X > 0):
    return 100
  false?

Hoge(X: int): int =
  var Y: int

  if (Y = BePositive[X]):
    Y
  else:
    -1
```

## 引数の順番

- 引数は、基本的に定義した順番に指定する
- 宣言で名前付き引数が定義されているときは、呼び出すときにその名前を呼出時に指定する必要がある
- 名前付き引数が複数定義されているときは、引数の順番に関係なく渡すことができる
  - サイドエフェクトが発生する可能性がある
 初期値が指定されている名前付き引数のときは呼び出し順を省略できる

```Verse
# 定義
SampleFunction(A: int, B: int, ?C: int, ?D: int, ?E: int = 100): int =

# 呼び出し例
var Z1: int = SampleFunction(1, 2, C := 3, D := 4, E := 5)
var Z2: int = SampleFunction(1, 2, D := 4, C := 3, E := 5)
var Z3: int = SampleFunction(1, 2, E := 5, D := 4, C := 3)
var Z4: int = SampleFunction(1, 2, C := 3, D := 4)
var Z5: int = SampleFunction(1, 2, D := 4, C := 3)
```

## タプルのアンパック

- 複数の引数を宣言している場合、型の構成が引数の並びと同じタプルを渡すことで、それぞれの引数にタプルの要素を渡すことができる。

```Verse
SampleFunction(A: int, B: string): void = {}

var T1: tuple(int, string) = (1, "ABC")

SampleFunction(1, "ABC")
SampleFunction(T1)
```

- 複数の引数宣言が行われた場合、以下の `宣言1` と `宣言2` は同じ定義になる

```Verse
# 宣言1
SampleFunction(A: int, B: string): int = A

# 宣言2
SampleFunction(X: tuple(int, string}): int = X(1)
```

## 型宣言のみの引数

- 引数が本体内のどこでも参照しないときは、型だけ宣言することができる
  - Javascriptで、引数名の接頭辞として `_` を付けたときと同じ効果がある
- これが存在するのは、引数として渡ってきたタプルがアンパックされたときに、必要な要素だけ使いたい可能性があるため

```Verse
SampleFunction(:any, B: string): string = B

var T2: tuple(int, string) = (5, "FOX")

S1: string := SampleFunction(T2) # = "FOX"
```

## 関数型

- パラメータとして関数を渡す際に使われる
- `type` キーワードを使用する
- 渡したい関数のパラメータとその型、エフェクトと結果の型を指定する

```Verse
type{_(:param_type1, :param_type2, ...)<effect>:ret_type}
```

- 関数型を使ったパラメータの例を以下に示す

```Verse
SampleFunction(A: int, B: type{_(:int):logic}): logic = B(A)

# 例
Func(X: int): logic = X > 0

var Y: logic := SampleFunction(100, Func) # true
```

## 関数のオーバーロード

- 同じ関数名でも、パラメータと結果で区別できるときは宣言できる
  - この宣言方式のことを、関数の**オーバーロード**と呼ぶ
- `<decides>`エフェクトが付与されていてもオーバーロード可能

```Verse
Func(X: int): int = X * 2
Func(X: float): float = X * 3

Func(1) # 2
Func(1.5) # 4.5
```

- ただし、パラメータ・結果で区別できないときはオーバーロードできない
- 以下の例だと、引数がタプルの場合、そのタプルが配列のサブクラスのときは最初の宣言だけですべて賄えるため

```Verse
Func(X: int, :any):int = X
Func(X:[]int)<decides>:int = X[0]
```

## 関数とメソッド

- クラス定義の一部として宣言される関数は**メソッド**と呼ばれる
- メソッドは、関数にいくつかの機能が追加される
- クラスとインタフェース、クラスの継承ではオーバーロードは起きない
  - かわりに、メソッドのオーバーライドはできる
