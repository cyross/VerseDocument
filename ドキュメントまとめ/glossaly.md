# Verse 用語辞典

## 数字と記号

## A

### abstract class (抽象クラス)

クラス またはクラス メソッド に抽象的な 指定子 が含まれている場合、そのクラスの インスタンス を作成することはできません。抽象クラスは、すべてではなく一部の メンバー が実装または指定された スーパークラス として使用されます。基本クラス とも呼ばれます。

### abstraction (抽象化)

ユーザーが隠された複雑な部分を理解する必要がない場合にユーザーから不必要な詳細を見えないようにする、プログラミングの原則です。たとえば、自動販売機の仕組みを理解していなくても、自動販売機にお金を入れて商品を購入することはできます。

### access level (アクセス レベル)

メンバー にアクセスするのに必要な権限です。これらの権限は、メンバーの 指定子 を使って指定されます。

### access specifier (アクセス指定子)

### アクセス 指定子 は アクセス レベル を定義します。以下のアクセス指定子をクラスに使用することができます。

- `public`
  - アクセスに制限がありません。
- `internal`
  - 現在の モジュール にアクセスが制限されます。これがデフォルトのアクセスです。
- `protected`
  - 現在のクラスと サブクラス にアクセスが制限されます。
- `private`
  - 現在のクラスにアクセスが制限されます。

### additive effect (加算エフェクト)

加算エフェクト は、排他的エフェクト に追加できる エフェクト です。加算エフェクトには `suspends` と `decides` が含まれます。

### agent (エージェント)

エージェントは プレイヤー または AI のいずれかを表します。

### algorithm (アルゴリズム)

アルゴリズムは、問題を解決したりタスクを達成したりするために記述される一連の命令であり、料理のレシピのようなものです。問題を解決したりタスクを達成したりするコードを記述した場合、そのコードがアルゴリズムに該当します。

### alternate integers (代替整数)

「16 進数」を参照してください。

### any

Verse には、(その他すべての型を `any` のサブタイプにする) すべての型のスーパータイプである、`any` という特殊な 型 があります。そのため、この型はほとんど 演算 をサポートしておらず、この型がサポートするすべての演算はすべての 値 でサポートされていなければなりません。この型はあまり使用されることはありません。ただし、コードの作成時に エラー が発生した場合に使用されることがあるため、この型があることを知っておくとよいでしょう。こういった状況は、結果として複数の異なる式が出力されて (`if` 式による複数のパスなど)、これらに共通するスーパータイプが `any` のみである場合によく発生します。

### API

アプリケーション プログラミング インターフェースの略語である API は、ユーザーが Unreal およびフォートナイト システムにアクセスしてやり取りできるようにするために、全般的に一連の 呼び出し可能な 関数、型、データ構造体にグループ化される ライブラリ です。

### archetype (アーキタイプ)

アーキタイプは、クラス内の フィールド が 値 で完全に定義される クラス の インスタンス です。

### archetype instantiation (アーキタイプインスタンス化)

アーキタイプ を作成するプロセスです。ロジック や他の 関数 も実行できる コンストラクタ と比較してください。

### argument (引数)

関数呼び出しからマッピングされた 関数シグネチャ の パラメータ に割り当てられる 値 です。

### array (配列)

配列は、同じ 型 の要素を格納できる コンテナ です。配列の要素は配列に挿入した順番で配置され、それらの要素には インデックス と呼ばれる配列内の位置に基づいてアクセスできます。

配列は、キーワード `array` とそれに続く `{}` を使用することで作成できます。次に例を示します。

```Verse
Players : []player = array{Player1, Player2}
```

詳細については、「配列」を参照してください。

### assignment expression (代入式)

Verse では、変数 を 初期化 したり、変数 の値を変更したりするときなどに、代入 式 によって 可変 の場所に 値 を格納します。

### async (非同期)

async 式は評価に時間がかかる可能性がありますが、必ずしも評価する必要はありません。async 式は、現在または後続の シミュレーションの更新 で完了することもあれば、完了しないこともあります。suspends 指定子で識別された async 関数は コルーチン とも呼ばれます。async 式と immediate 式はそれぞれ対照的なものです。

### async context (async コンテキスト)

コルーチン 呼び出し などの async 式が許可される場所の スコープ です。

### atomic (アトミック)

他のコードによる中断 (観察) なしに、完全に 実行 されるか、完全に 失敗 する単一の完全なコード単位です。アトミック コードは中断することはできません。隣接する async ではない immediate 式 すべてはアトミックとみなされ、それらのコードは同じ更新内で中断なく、プリエンプション または コンテキスト スイッチ なしで確実に実行されます。

### attribute (属性)

属性とは、Verse や UEFN などのアプリケーションで参照または分析可能な 識別子 に関連付けられたプロパティやその他の情報を指します。

その属性 構文 では、`@ `に続けてその属性の キーワード を使用します。

## B

### base-16 (基数 16)

16 進数 (英語の Hexadecimal は 6 を意味する hexa- と 10 を意味する decimal から成る) または基数 16 (hex とも略される) は、基数 10 で使用する慣れ親しんだ 10 個のシンボルの代わりに 16 個のシンボルを使用する進法です。

### bidirectional (双方向)

2 つの方向に機能することを意味します。

### bind (バインド)

コンピュータ プログラミングでは、バインド は 2 つ以上のプログラミング オブジェクト の間に一定時間つながりを生み出すことです。

### block expression (ブロック式)

ブロック式は、複数の式を単一の式としてグループ化する方法、または コード ブロック を ネスティング する方法です。ブロック式はコード ブロックと同じように動作します。

### body (本体)

関数 本体や ループ 本体など、言語要素の部分式を定義する独自の スコープ を持つ ブロック です。たとえば、関数本体には、その関数の機能を定義する式が含まれており、その関数で 宣言される 変数 は、関数本体に対して ローカル になります。

### Boolean (ブール)

「ブール ロジック」を参照してください。

### Boolean logic (ブール ロジック)

表現される値の真偽を表すロジックの体系で、プログラミング言語では フロー制御 の定義によく使用されます。論理学と代数学に大きく貢献した数学者である George Boole (1815 ～ 1864) にちなんで名付けられました。

Verse では、真偽の判断に使用されるこの 型 は `logic` です。このブール ロジックは、失敗コンテキスト における 失敗する可能性がある式 全体に適用されます。

### bound (バウンド)

バインド が実行された変数です。すべての Verse 変数 は定義されるとすぐにバインドされます。これらの変数は未バウンドのステートになることはできません。

### braces (中括弧)

「ブラケット」を参照してください。

### bracket (ブラケット)

Verse では、コード内に含まれる異なるタイプの情報を指定する際に括弧を使用します。Verse では 4 種類の括弧を使用します。それぞれの使用目的は主に次のとおりです。

- `()` 括弧
  - 関数呼び出し に含まれる 関数シグネチャ と 引数 でのパラメータの設定と、式、タプル および サブクラス のグループ化に使用します。
- `[]` ブラケット
  - 角括弧とも呼ばれる
  - 失敗する可能性がある関数呼び出し、配列およびマップの型指定子、配列へのインデックス化に使用します。
- `{}` 中括弧
  - アーキタイプインスタンス化、コード ブロックの書式化、文字列補間で使用します。
- `<>` 山括弧
  - 識別子 および 関数 に指定子を追加する際に使用します。

### branch expression (branch 式)

`branch` 式 は、1 つ以上の `async` 部分式の ブロック を開始します。後続の式はすぐに 実行されます。

詳細については、「並列処理」を参照してください。

### break

現在の `loop` を「抜け出して」、loop 式の後の式を 実行する 式 です。詳細については、「loop と break」を参照してください。

### bug (バグ)

バグとはコンピュータ プログラム内で生じるエラーであり、不適切または予期しない結果が出力される原因となります。Verse のコンパイル時に発生する コンパイラ エラー とは対照的に、バグは ランタイム時 に発生します。バグを特定して除去するプロセスは デバッグ と呼ばれます。

### build (ビルド)

Verse コードをコンピュータで 実行 可能な命令に コンパイル することを指します。

### built-in (組み込み)

一部のプログラミング言語では、そのプログラミング言語と 標準ライブラリ 内で直接使用できる要素を「組み込まれた要素」とします。

### built-in type (組み込み型)

組み込み 型 は、複合型 と違ってそれ以上分割できません。

## C

### C++

さまざまなアプリケーション (特に Unreal Engine などのゲーム エンジン) で使用される、よく知られている言語です。

### cache (キャッシュ)

データを格納して、より迅速にアクセスできるようにするための方法です。

### call (呼び出し)

コンピュータ プログラムでは、プログラムによって命令が要求されたときに、その命令が 呼び出されます。この呼び出しにより、特定の 関数 が 起動 (アクティブ化) されます。呼び出しは、プレイヤーと オブジェクト とのインタラクションや時間のパラメータによって発生します。

### call graph (コール グラフ)

実行時間やタイムスタンプなどの各 呼び出し に関する情報と 関数 の 識別子 を含む、コール スタック の メソッド のリストです。

### call stack (コール スタック)

コール スタックは、プログラムで呼び出し (実行されている関数、完了した関数、まだ実行されていない関数) を記録するために使用されるものです。

### caller (呼び出し元)

呼び出し を行う 式 です。

### canceled (キャンセル)

完了 前に終了した タスク の ステート です。

### case expression (case 式)

case 式を使用すると、さまざまなオプションを使ってプログラムのフローを制御できます。詳細については、「case」を参照してください。

### Ceil

有理数 値 を最も近い 整数 に切り上げる 数学演算 です。`Floor` と比較してください。

### changelist (チェンジリスト)

コンピュータに格納されるローカル ファイルとサーバーに送信されてプロジェクトのソース ファイルとマージされるファイル間の変更を Perforce で追跡する方法です。チェンジリストは CL とも呼ばれます。

### char

単一の文字を格納するデータ型です。

### character (キャラクター)

Verse では、キャラクターは文字列内の単一の表記上の要素を指すこともあります。

### character encoding (文字エンコーディング)

文字エンコーディングは、コード ポイント と呼ばれる、コンピュータが理解できるテキスト文字とデータ間のマッピングです。

### CI/CD

CI/CD とは、継続的インテグレーションと継続的デリバリ (継続的デプロイ) を指します。CI/CD は、アプリケーションのビルド、テスト、デプロイの自動化によって開発とアプリケーションの橋渡しをします。

### class (クラス)

クラスは、同じような動作とプロパティ (変数とメソッド) の オブジェクト を作成するためのテンプレートであり、実数値を持つオブジェクトを作成するには インスタンス化する 必要があります。クラスは 階層的 であるため、親 (スーパークラス) から情報を継承して子 (サブクラス) と共有できます。クラスは、ユーザーが定義するカスタム型の場合があります。インスタンス と比較してください。

### code (コード)

ソース コードと呼ばれることもあるコードは、プログラマーが記述する命令であり、ソフトウェア プログラムに動作を指示します。Verse のソース コードは、プログラマーが読んで理解できますが、コンピュータではそのまま処理できません。コンピュータでプログラムを読み取って実行できるようにするには、プログラムをコンピュータで実行可能な命令に変換する必要があります。この処理を コンパイル と呼びます。プログラマーがコーディングという場合、それはこうした命令を記述することを意味します。

### code block (コード ブロック)

ブロック、または コード ブロック は、新しいコードの 本体 を導入する 式 のグループです。式が含まれていないコード ブロックもありますが、これは通常、後でどこかの時点で式が入力されるプレースホルダーです。

コード ブロックは、識別子 の後に続きます。

Verse のコード ブロックには 3 つの形式がありますが、それらの形式はすべて、コードの実際の機能を変えないという点で 意味的に 同じです。

スペース入りの形式 では `:` でブロックが開始され、各式は 4 つのスペースでインデント付けしたそれぞれに独自の行の後に続きます。

```Verse
if (test-arg-block):
    expression1
    expression2
```

`if (test-arg-block)` はブロックの一部ではなく、ブロックは `:` を含む行の最後に始まることに注意してください。`;` を使用して単一の行の複数の式を区切ることもできます。

```Verse
if (test-arg-block):
    expression1; expression2; expression3
```

複数行の形式 では、ブロックが `{}` (中括弧) で囲まれ、式は新しい行に配置されます。

```Verse
if (test-arg-block)
{
    expression1
    expression2
}
```

スペース入りの形式と同じように、`;` を使用して単一の行の複数の式を区切ることもできます。

```Verse
if (test-arg-block)
{
    expression1; expression2
}
```

3 つ目の形式は、単一行の中括弧で囲まれた形式 です。ここでもブロックは `{}` で囲まれますが、各式は新しい行に配置されるのではなく `;` で区切られます。各行に `{}` 文字を入れる必要がないことに注意してください。

```Verse
if (test-arg-block) {expression1; expression2}
```

詳細については、「コード ブロック」を参照してください。

### code comment (コード コメント)

「コメント」を参照してください。

### code point (コード ポイント)

文字エンコーディング のための Unicode コード スペースの値です。

### code sample (コード サンプル)

1 つ以上の概念、クラス、関数、またはその他いくつかのプログラミング言語の特徴を示す、スタンドアローンのプログラム、モジュール、クラスです。コード スニペット と比較してください。

### code snippet (コード スニペット)

スニペットは、通常は特定の概念を示す (実装する) ことを目的とする、短いコードです。

コード スニペットは、単独で動作するプログラムではありません。コード スニペットは、コード ブロック にコピーアンドペーストできます。コード サンプル と比較してください。

### code unit (コード単位)

エンコードされたテキストの単位を表すことができる、最小のビットの組み合わせです。UTF-8 では、コード単位に 8 ビットを使用します。

### coercion (強制)

値 を別のデータ 型 に変換することを指します。型の変換は、暗黙的または明示的に行うことができます。強制とも呼ばれる暗黙的変換は自動的に行われます。

### comment (コメント)

プログラマーが記述するコメントであり、コードの説明や特定のプログラミングについての理由を示します。コード自体にはプログラムの「方法」が示される一方で、通常、コメントにはその「理由」が記録されます。

コード コメントは `#` で始まり、コード内のさまざまな場所に残せます。プログラムの実行時には、コード コメントは無視されます。

コメントは、行の最初に `#` を入れて 1 行 で記述できます。行末で改行するとコメントが終了します。

```Verse
# 1 行で記述したコメントはこのようになります。

<# でブロックを開始して #> で終了することにより、複数行のブロック コメントを記述できます。

<# このようにコメントを開始して
コードに複数行の
コメントを記述し、終了します。
#>
```

コードにコメントを追加するその他の方法については、「Verse 言語のクイック リファレンス」を参照してください。

### commit (コミット)

失敗する可能性がある式 が成功した後に、その式のコード エフェクトが永続的になるタイミングです。

### common type (共通型)

共通型は、頻繁に使用される 組み込み の 型 です。共通型には `any`、`comparable`、`float`、`int`、`logic`、`rational`、`string` が含まれます。

### comparable

小なりや大なりなどの 演算子 を定義する 型 です。他の型は `comparable` を 継承 し、比較式 を実行できます。

### comparison expression (比較式)

Verse では、不等価 演算子 (`<`、`>`、`<=`、`.=`、`<>`) のいずれかを使用して 2 つのものを比較するときに比較 式 が実行されます。

### compile (コンパイルする)

人間が読み取れる言語からコンピュータが実行可能な命令にプログラムを変換することです。

### compile time (コンパイル時間)

ソース コードがマシン命令に変換される時間を指します。ランタイム と比較してください。

### compiler (コンパイラ)

人間が判読可能なプログラムの命令をコンピュータが実行できる命令に変換するソフトウェアです。パーサー とも呼ばれます。コンパイラが実行される期間は コンパイル時間 と呼ばれます。

### compiler error (コンパイラ エラー)

コンパイラ エラー は、コンパイル時 に Verse コンパイラによって不適切なコードの使用が検出された場合に発生します。ランタイム時 に生じる バグ と比較してください。

### completed (完了)

実行されて完了した タスク のステートです。

### component (コンポーネント)

再利用可能なプログラム内の 1 つの機能、または関連する機能のグループです。

### composite type (複合型)

合成 や 集約 と呼ばれることもある複合データ型は、プリミティブ型やその他の複合型の (通常は名前付きの) フィールドか要素で構成されることがある 型 です。通常、その有効期間中は一定数のフィールドまたは要素が含まれます。現時点で、Verse では構造体、クラス、列挙型、インターフェース、モジュールの複合型が使用されています。

### computes

この エフェクト は、関数 が同じ入力を繰り返し提示されたときに同じ出力を返すことを示します。

### concatenate (結合する)

「結合」を参照してください。

### concatenation (結合)

結合は、文字列 が別の文字列に付加 (追加) されるときに行われます。文字列は、演算子 + で結合できます。

### concrete class (具象クラス)

具象 指定子 を持つ クラス は、空の アーキタイプ でクラスのインスタンスを構築する方法です。つまり、クラスのすべてのフィールドは初期 値 で定義する必要があります。

### concurrent (並列)

同じ有効期間に 実行 される複数の演算処理は並列です。単一のプロセッサでの物理時間を考えて、必ずしも 同時 ではなかったとしても、論理シミュレーションの更新、ティック、フレームにおいてオーバーラップがある場合は並列になります。

### condition (条件)

条件は、プログラムで `true` か `false` かをチェックできるものです。条件式は条件を評価し、`true` か `false` の結果を返すことができます。

### conditional (条件付き)

条件を 評価 し、その条件の 結果 に基づいて命令を 実行する 式 です。条件付きの例としては if 式 があります。

### constant (定数)

定数は値が格納される場所であり、プログラムのランタイム中はその値を変更できません。常に同じであることから 定数 と呼ばれます。

定数の基本構文は `name : type = value` です。`name` は定数に割り当てる名前 (識別子) です。`:` は 型 が次に来ることを示しています。`=` は 値 が来ることを示しています。続いて値自体を指定します。次に例を示します。

```Verse
PlayerSpeed : float = 2.0
```

|  Declaration  |     |         | Initialization |            |
| :-----------: | :-: | :-----: | :------------: | :--------: |
| Constant Name |  :  |  Type   |       =        | Expression |
| `PlayerSpeed` | `:` | `float` |      `=`       |   `2.0`    |

これは、プログラムの実行中に変わることがない、2.0 (10 進値) という値が `PlayerSpeed` に設定されていることを示しています。

定数には常に値が割り当てられています。名前と型は 宣言 であり、値が表現されるところは 初期化 です。

変数 と比較してください。

詳細については、「定数と変数」を参照してください。

### constrained (制約)

式に制約があるということは、制限が設定されていることを意味します。

### constructor (コンストラクタ)

コンストラクタは、関連付けられた クラス の インスタンス を作成する特殊な 関数 であり、新しい オブジェクト の初期 値 を設定するために使用できます。

クラスのコンストラクタは、関数名に `constructor` 指定子 を付けることによって追加できます。関数で 戻り値 の 型 を指定するのではなく、関数にクラス名が割り当てられた後にフィールドが 初期化 されます。クラスには複数のコンストラクタを含めることができます。

### container (コンテナ)

コンテナは、コードのデータを整理する方法です。詳細については、「コンテナ型」を参照してください。

### container type (コンテナ型)

配列、マップ、タプル、オプション などの コンテナ 型を使用することにより、複数の値をまとめて格納できます。

### context (コンテキスト)

言語のさまざまな要素とコンストレイントの ライフタイム を定義するコードの スコープ です。これは通常、コード ブロック の開始から終了までの範囲です。

### context switch (コンテキスト スイッチ)

コンテキスト スイッチは、後からリストアして 実行 を再開できるように、プロセスや スレッド の ステート を格納し、前に保存した別のステートをリストアする処理です。

### contract with the genie (悪霊との契約)

コードの記述は、プログラムが命令を厳密に実行しても、まさに期待していた結果が得られるとは限らないという点において、「悪霊との契約」に例えられることがあります。「プログラム」も参照してください。

### control flow (制御フロー)

コンピュータが各命令を 実行 する順番です。Verse には、プログラム内のこの流れを制御するために、ブロック や ループ といったさまざまな式があります。

### converges

「最小」の エフェクト セットです。発散する ことなく限られた時間で値を生成することが保証されているコードです。

### coroutine (コルーチン)

経時的に処理を実行するか、さまざまなイベントや ステート が起きるのを待つか、それら両方に該当する、持続的な 有効期限 のあるルーチンです。コルーチン は async 関数 と同義です。

## D

### data (データ)

一般的に、データとは 式 で使用される 値 を指します。

### data member (データ メンバー)

「メンバー」を参照してください。

### data type (データ型)

「型」を参照してください。

### debugger (デバッガ)

デバッグに使用されるツールで、実行ステップごとにプログラムの ステート を確認することができます。

### debugging (デバッグ)

コードのエラーを特定して解決する処理です。

### decides

関数 が 失敗 する可能性があることと、この関数を 呼び出す ことが 失敗する可能性がある式 であることを示す エフェクト です。`decides` エフェクトを持つ関数 定義 は transacts エフェクトも保持している必要があります。つまり、関数のいずれかの部分でエラーが発生した場合に、この関数によって実行されるアクションを (アクションが実行されなかったかのように) ロールバック できます。

### decision expression (判定式)

判定式は、演算子 `not`、`and`、および `or` を使用して、成功と失敗の判定フローを制御します。

### declaration (宣言)

宣言は、識別子 とその 型 を導入する 式 です。これは実装 (使用) されることもされないこともあり、値 についても割り当てられる (初期化される) ことも、そうでないこともあります。

変数を宣言するための 構文 は `var name : type = expression` です。次に例を示します。

```Verse
var PlayerSpeed : float = 2.0
```

このコード行は、`PlayerSpeed` という名前の 変数 に `float` 値があることを宣言しています。

この例では、最後の部分の `= 2.0` が 初期化 を表しており、宣言から分離されています。

### declarative programming (宣言型プログラミング)

このプログラミング パラダイム では、プログラムを段階的に実行することよりも、どのように ではなく 何を を行うかを指定し、望ましい最終結果を得ることに重点を置くものです。

### declare (宣言する)

識別子 と 型 を指定することにより、変数 か 関数 を宣言します。初期化 と比較してください。

### decorate (装飾する)

コードを記述するとき、装飾するとは、コードの一部をほかのコードでラップすることです

### defer

`defer` 式は、コードの実行を現在の スコープ が終了するまで遅らせます。この式は、変数 をリセットする場合などのクリーンアップ タスクに役立ちます。

### define (定義する)

「定義」を参照してください。

### definition (定義)

関数定義やクラス定義など、定義は 識別子 が実装されるか、識別子に値が割り当てられたときに行われます。宣言 と比較してください。

### dependency (依存関係)

依存関係は、モジュール が何らかの機能を実行するために他のモジュールに依存している状況です。

### deterministic (決定論的)

決定論的システムは、同じ初期ステートまたは入力で常に同じ結果がもたらされるシステムです。

### deterministic destruction (決定論的デストラクション)

決定論的デストラクションは一部のプログラミング言語で取り入れられており、プログラムがその スコープ を終了した際に オブジェクト が破壊されることを示します。

### developer (デベロッパー)

UEFN および Verse では、ユーザーを デベロッパー (開発者) と呼びます。この用語にはフォートナイトの島のクリエイター、アーティスト、建築家も含まれます。

### digest (ダイジェスト)

モジュール、関数、クラスなどの Verse コンパイラで処理されたすべての パブリック シンボル の自動生成されたリストです。これには コメント も含まれます。ダイジェスト ファイルで関連する モジュール 内の API や機能を確認できます。

### dispatch (ディスパッチする)

ディスパッチとは、何かをどこかに送信することを指します。Verse では、たとえば関数に呼び出しをディスパッチすることもあれば、リスナーにイベントをディスパッチすることもあります。

### diverge (発散する)

プログラムの 実行 は、期待どおりに終了しなければ「発散」します。発散することなく限られた時間で値が生成された場合、その実行は 収束 (converges) します。

### doc

関連する要素の動作やその使用方法など、役立つ情報を含む クラス と 関数 (関数パラメータではない) にある全般的なメモ フィールドであり、Verse の API リファレンスに含まれるその要素のページへの情報記載に使用されます。

### domain (ドメイン)

ドメインは、特定のパラメータで受け入れられた一連の入力です。型 はドメインを指定する 1 つの方法ですが、ドメインは型より包括的です。

### dynamic typing (動的型付け)

動的型付けプログラミング言語では、変数と式に割り当て済みの型がありません。そのため、ランタイムまで検証することができません。強い型付け と比較してください。

## E

### editable (編集可能)

UEFN でプロパティを公開するためにコードに追加できる 属性 です。この属性によるコードのタギングでは、次のようにフィールド 識別子 の前に `@attribute_name` (このケースでは `@editable`) を追加します。

```Verse
@editable
PropertyName : type = DefaultValue
```

たとえば、`GreetingMessage` フィールドが編集可能な属性で、デフォルト値である `"Hello, stranger"` が指定されています。

```Verse
expose_properties := class(creative_device):
@editable
GreetingMessage : string = "Hello, stranger"
```

このプロパティの使用方法の詳細については、「仕掛けのプロパティをカスタマイズする」を参照してください。

### effect (エフェクト)

エフェクトは、関数 で示すことができる動作のカテゴリです。

以下の例では、関数 が「`IsCriticalHealth`」と命名され、`Health` パラメータ で入力として `float` 値 を取得することがコードで述べられています。次に、関数が示すエフェクトが `decides` と `transacts` であること、つまり関数が 失敗コンテキスト であり、失敗した場合はそのアクションを ロールバック できることが述べられています。関数に入力として渡される `Health` 値が 0.0 より大きく、30.0 以下の場合、関数は成功します。それ以外の場合は関数が失敗し、その関数を呼び出したコンテキストで失敗を処理する必要があります。

```Verse
IsCriticalHealth(Health : float)<decides><transacts> : void =
((Health > 0.0) && (Health <= 30.0))
```

この詳細については、「指定子と属性」を参照してください。

### effect hierarchy (エフェクト階層)

エフェクトは、関数 で示すことができる動作のカテゴリです。関数に対する 排他的エフェクト の適用には階層があり、階層内の上位のエフェクトは少なくとも下位のすべてのアクションを許可します。階層は次のとおりです。

- `transacts`
- `varies`
- `computes`
- `converges`

`transacts` エフェクトには下位のエフェクトのプロパティが含まれ、`varies` エフェクトには `computes` および `converges` エフェクトが含まれますが、`transacts` は含まれないといったようになります。

### element (要素)

より大きなグループの単一の部分です。たとえば、配列 には、個別に格納して使用できるさまざまな要素を含めることが可能です。

### emoji (絵文字)

絵文字は、一般的に色彩豊かな形で表され、テキスト行内で使用されるピクトグラム (絵のシンボル) です。絵文字は、顔、天気、乗り物や建物、食べ物や飲み物、動物や植物などのものや感情、気持ち、アクティビティを表すアイコンを示します。絵文字の標準は、Unicode Consortium によって定められています。

異なる意見もありますが、英語では複数形として emoji と emojis のどちらも使用できます。🤦

### empty block (空ブロック)

含まれる 式 がない (0 個の) コード ブロック は空ブロックです。空ブロックは、一般的にプレースホルダーとしてのみ使用され、後でコードが入力されます。

### empty string (空文字列)

文字を含まない 文字列 `""` は空文字列です。

### enum (列挙型)

enum は enumeration の省略形であり、一連のものを指定またはリストすることを意味します。これは、曜日やコンパスの方位などに使用できる Verse の型です。

`enum` は キーワード です。

### equality expression (等価式)

Verse では、`=` 演算子 を使用して 2 つのものが等しいかどうかを比較するときに等価式を使用します。

### escape character (エスケープ文字)

Verse のエスケープ文字は バックスラッシュ ( `\` ) であり、これによって 文字列リテラル内にエスケープシーケンスが作成されます。これは、そうしなければ別の意味に解釈されてしまう制御文字を変更するために使用されます。たとえば、文字列 を処理する中で、`{ }` などの使用法があらかじめ定められた文字を含めたい場合は、文字列のその文字の前にエスケープ文字 「`\`」 を入れる必要があります。これにより、`"\\{\\}"` がテキストで `{}` とレンダリングされます。

### evaluate (評価)

評価するとは、式 を 実行 して 値 を生成することを指します。

### event (イベント)

イベントは、識別可能なアクションまたは出来事です。たとえば、ボタンの仕掛けに、プレイヤーがこのボタンとやり取りするたびに発生する `InteractedWithEvent` があるとします。この場合は、イベント ハンドラ をサブスクライブすることで、特定のイベントが発生する際の動作を定義できます。

### exclusive effect (排他的エフェクト)

いくつかの エフェクト は、加算エフェクト を追加できる 排他的エフェクト とみなされます。ただし、こうしたエフェクトは他の排他的エフェクトと一緒には使用できません。排他的エフェクトには `computes`、`varies`、および `transacts` が含まれます。加算エフェクトには `suspends` と `decides` が含まれます。

### execute (実行する)

プログラムを実行することを指します。

### execution (実行)

プログラムを解釈し、そのプログラムからの命令を実行するコンピュータの処理です。

### expose (公開)

プロパティ は Verse コードで `editable` な 属性 を割り当てることによって UEFN で 公開 されます。これは、公開されているプロパティを UEFN インターフェースで直接編集することができることを意味しています。「編集可能」も参照してください。

### expression (式)

式は、評価されたときに 結果 を示すコードの最小単位 (値 と 関数 の組み合わせ) です。

以下の例は `if ... else` 式であり、値が指定された基準を満たすとある処理を実行し、満たさないと別の処理を実行することを意味します。

```Verse
if (a > 5):
    “Big!”
else
    “Small!”
```

Verse では、リテラル から 関数呼び出し や 制御フロー までのすべてが式になっています。

これは、結果値を持たないスタンドアローンのコマンドである 文 と比較されます。Verse では、すべてが式になっており、値に対して評価できる文と式の区別はありません。

詳細については、「式」を参照してください。

## F

### f

「float」を参照してください。

### fail (失敗する)

Verse では、ユーザーが記述したコードがデフォルトで失敗することはありません。これは、ブール やオプションを返す関数を持つのではなく、`<decides>` を使用して、値、void を返す、または失敗のいずれかを返すことを意味します。

### failable expression (失敗する可能性がある式)

失敗する可能性がある式は、成功して 値 を生み出すか、失敗して値を返さない 式 です。失敗する可能性がある式の例には、配列 への インデックス処理 (無効なインデックスは失敗するため) や、2 つの 値 の比較など、演算子 の使用があります。

### failure (失敗)

Verse では、失敗には単純なブール値以上の意味があります。失敗によって 制御フロー が動作します。失敗する可能性がある式 は、成功して値を生成することもあれば、失敗して値を返さないこともあり、ブール値によって制御フローが決定される他のプログラミング言語とは違って、失敗コンテキスト のみで使用できます。

### failure context (失敗コンテキスト)

失敗コンテキストは、失敗する 可能性がある 式 を 実行できる コンテキスト です。このコンテキストでは、式が失敗した場合の動作が定義されます。

### field (フィールド)

「メンバー」を参照してください。

### final

クラス とクラスの メンバー のみで使用できる 指定子 です。

クラスに final 指定子がある場合、そのクラスの サブクラス を作成することはできません。

フィールドに final 指定子がある場合、サブクラスのフィールドをオーバーライドすることはできません。

メソッド に final 指定子がある場合、サブクラスのメソッドを オーバーライド することはできません。

### fire-and-forget (ファイアアンドフォーゲット)

ファイアアンドフォーゲットとは、ユーザーが完了するタイミングや正常に完了するかどうかを気にすることがない式を指します。このような式は非常にまれです。

### float

浮動小数点数を格納して処理するために使用する演算の型です。Verse でサポートされる 3 つの主要な数値型の 1 つであり、他には int と rational があります。

### floatingpointnumber (浮動小数点数)

小数値のある変数、または 0.5 や 1.0 などの小数点を含む数を定義するためにさまざまなプログラミング言語で用いられる用語です。float 変数 宣言 を使用して作成された数には、小数点の両側に桁があります。

### Floor

有理数 値 を最も近い 整数 に切り下げる 数学演算 です。Ceil と比較してください。

### for expression (for 式)

`for` ループ と呼ばれることもある `for` 式 は、`for` 式には 制約 (`for` ループの実行前にイテレーションの数がわかっている) があり、ループを終了するタイミングが自動的に決定される点を除き、loop 式と同じです。詳細については、「for」を参照してください。

### frame (フレーム)

フレームとは、特定の時点におけるシミュレーションを表現する、完全にレンダリングされた個別の画像 (コンピュータや TV の画面など) です。フレームは シミュレーション の更新 (またはティック) と同義で使用される場合があります。これは、これらが通常は連携しているためです。ただし、新しいフレームは、シミュレーションの更新とは異なるレート (より高い、または低いレート) にすることができます。フレームレート、または省略して fps (frames per second) は、1 秒間に現れるフレームの数です。

### function (関数)

関数 (ルーチン とも呼ばれる) は、アクションを実行したり、入力に基づいて出力を作成したりするための命令を出す再利用可能なコードです。

関数を定義するには、ユニークな名前、その 結果 として期待される情報の型、そして 呼び出した ときにその関数が行う動作という 3 つの重要な部分を提供する必要があります。

以下は、関数の基本構文です。

```Verse
name() : type =
    codeblock
```

#### コロンで区切られた name() と type

この部分が 関数シグネチャ で、この関数の呼び出しと使用、そしてこの関数で返されるべき 値 の型を指定します。この形式は、`name` の後の `()` を除いて、コードで関数を呼び出す方法を模倣する [定数}(#定数) を作成する方法に似ています。

#### 関数のコード ブロック

`=codeblock` を指定して、関数が呼び出されたときに行うことを定義します。`codeblock` は 1 つ以上の一連の式です。関数を呼び出すたびに、コード ブロック 内の式が実行されます。

| Function Signature |            |            |     |          |     |       |             |  -  |      　      |
| :----------------: | :--------: | :--------: | :-: | :------: | :-: | :---: | :---------: | :-: | :----------: |
|     Identifier     | Parameters |            |     |          |     | :　　 | Return Type | =　 |     - 　     |
|    `OrderFood`     |    `(`     | `MenuItem` | `:` | `string` | `)` |  `:`  |   `food`    | `=` | `code block` |

### function call (関数呼び出し)

関数 を 評価する (呼び出す や起動するとも表現される処理を行う) 式 です。関数呼び出しには、関数に `decides` エフェクトが含まれるかどうかに応じて、`FunctionName()` または `FunctionName[]` の 2 つの形式があります。関数呼び出し式の 結果 の型は、関数シグネチャ で定義されます。

### function signature (関数シグネチャ)

関数シグネチャは、関数名 (識別子)、および関数の入力 (パラメータ) と出力 (結果) を 宣言します。Verse の関数には、関数の使用または実装方法を指定する 指定子 もあります。

### functional logic programming (関数型ロジックプログラミング)

関数型プログラミング と ロジック プログラミング の パラダイム を単一の言語に組み合わせたものです。

### functional programming (関数型プログラミング)

宣言型プログラミング の一種で、関数 の使用に焦点を当てます。関数型プログラミングでは、副次的エフェクト を減らすことで、テストとデバッグでの負担を軽減することを意図しています。関数型プログラミング言語の例としては Haskell などがあります。

### future

実行が開始されたものの、キャンセルされることなく一時停止状態になったタスクです。将来のどこかの時点で完了するため future と呼ばれます。

## G

### game loop (ゲーム ループ)

ゲーム ループは、プレイヤーとコントローラー/マウスとのインタラクションや、ゲーム ステート の更新などの入力に対応するために繰り返し実行 (ループ) されて、プレイヤーがゲーム ステートに及ぼした影響 (プレイヤーがボタンを押すとライトが灯るなど) を出力するコードです。通常、このループは、ゲームが 完了ステート (プレイヤーが目標を達成したときなど) または 失敗ステート (プレイヤーがゴールに到達する前に時間切れになるなど) に到達した際に終了します。

### game state (ゲーム ステート)

ゲームや他の シミュレーション の ステート (状態) です。システムを記述するすべてのデータ 値 で構成されており、定数 と 変数 の値によってシステム ステートが判断されます。

### generator (ジェネレータ)

ジェネレータは、1 回に 1 つずつ一連の 値 を生成し、シーケンスの値に名前を付けます。

### group (グループ)

`()` で 式 を囲むアクションです。これにより、評価順 が明示的に指定されます。グループ化によってコードの可読性を高めることもできます。

## H

### handler (ハンドラ)

ハンドラは、バインドされた イベントに対応するために呼び出される 関数 です。たとえば、関数をボタンの InteractedWithEvent にバインドすると、プレイヤーがそのボタンとやり取りするたびに、そのイベントに関連付けられているハンドラが呼び出されます。

### head node (先頭ノード)

連結リスト の最初の ノード を先頭ノード、最後のノードを末尾ノードと呼びます。

### hexadecimal (16 進)

Verse では、基数 10 を使用する 10 進数システムではなく、16 進数 (基数 16) システムを使用して整数を表すことができます。これは、0 ～ 9 の数字と A ～ F の文字で 16 進値が表されることを意味します。たとえば、0x7F は 127 と、0xFACE は 64206 と同じです。

これは、整数 を表す別の方法です。

### hierarchical (階層的)

ランク、重要性、または制御の明確なレベルや階層がある状態を指します。一般的な階層関係には、親/子やスーパークラス/サブクラスなどがあります。

## I

### IDE

統合開発環境 (IDE) は、プログラムの作成とデバッグのためのユーザーインターフェース (UI) を提供するソフトウェアです。

### identifier (識別子)

識別子は、変数 や 関数 などのプログラムに含まれる要素を一意に識別するために、プログラマーがそれらに付ける名前です。

### if expression (if 式)

`if` 式 を使用すれば、プログラムのフローを変える判断を行うことができます。他のプログラミング言語と同じように、Verse の `if` 式は条件付き実行をサポートしていますが、Verse では、判断のために条件で成功と 失敗 を使用します。

### immediate

immediate 式 は遅延なく評価を行い、現在の シミュレーションの更新 内で 評価 を完了させます。

### immutable (不変)

オブジェクトの作成後にその ステート を変えることはできません。可変 と比較してください。

### imperative programming (命令型プログラミング)

プログラムによって、プログラムの実行がステップごとに明確に示される パラダイム です。命令型プログラミング言語の例としては C などがあります。

### index (インデックス)

インデックスは、数値表現でシーケンスのアイテムの位置を表します。シーケンスは、リスト、一連の文字、または 値 の任意順序の場合があります。

インデックスは、ゼロベースのカウント を使用します。これは、インデックスの最初の位置が「0」に、5 番目が「4」になることを意味しています。

### infer (推測)

インスタンスの中には、定数の作成時などに型を明示的に指定する必要のないものがあります。たとえば `MyConstant := 0` では、整数値が割り当てられることから `MyConstant` の型は `int` であると推測されます。このようなインスタンスでは型が推測されます。

### infinite loop (無限ループ)

永久に繰り返されるループ ブロックです。「ループ」と「break」も参照してください。

### infix (インフィックス)

2 つの 被演算子 があり、それらの被演算子の間に演算子が置かれる 演算子 の形式です。

### inheritance (継承)

Verse では、他のクラスのフィールドやメソッドを追加または変更することで別のクラスの定義を広げる クラス を作成できます。1 つのクラスが別のクラスから定義を継承するため、これは多くの場合にサブクラス化や 継承 と呼ばれます。

### initialize (初期化)

変数 を作成するには、変数の宣言 と呼ばれる 識別子 と 型 の指定を行ってから、初期化 と呼ばれる変数への値の割り当てを行います。

### instance (インスタンス)

クラス のインスタンスは オブジェクト です。インスタンスには、実数値ではなくクラス型で定義されたものと同じ動作が含まれます。

### instantiate (インスタンス化する)

クラスや構造体などのデータ構造やデータ型の インスタンス や値を作成することを指します。「アーキタイプ インスタンス化」も参照してください。

### int

`1`、`-30`、`777` のような 整数 を格納して処理するために Verse で使用される 型 です。int には、小数部分のない正数か負数 (または 0) を含めることができます。Verse では、int に小数部分のない正数か負数 (または 0) を含めることができます。

### integer (整数)

整数は、正、負、または 0 のいずれかの (小数ではない) 整数です。

### interface (インターフェース)

インターフェースは、インターフェースを実装する クラス とのやり取りの方法に関するコントラクトを示す 型 です。インターフェースを インスタンス化する ことはできませんが、クラスはインターフェースを 継承 してそのメソッドを実装できます。

### internal class (内部クラス)

`epic_internal` とマークされたクラスのことで、そのクラスから独自のインスタンスを作成することはできません。内部オブジェクトへアクセスするため API のみを使用することができます。

### interpolation (補間)

既知の 2 つの値からその間にある新しい値を算出することを指します。

### interpreter (インタープリタ)

プログラムを 1 行ずつ分析して実行するプログラムです。

### invocation time (呼び出し時間)

式 の 評価 に要する時間です。即時 呼び出し は実質的にまったく時間がかかりません。async 式については、すぐに完了する場合もあれば休止する場合もあります。

### invoke (呼び出す)

「呼び出し」を参照してください。

### is-a relationship (is-a 関係)

親クラスと子クラスの関係を 「is-a」関係 と呼びます。is-a 関係にある子クラスは、その親クラスから 継承 します。

### iterate (イテレート)

各要素のコードを順に実行することを指します。

## J

## K

### key-value pair (キー/値のペア)

キーに値を関連付けると、それらが組み合わされてキー/値のペアになります。キーを使用することで値を参照できます。

### keyword (キーワード)

キーワードは、コンパイラ にとって特別な意味を持つ予約語です。キーワードの例としては、`for` や `class` などがあります。キーワードを識別子として使用することはできません。

## L

### lifespan (有効期限)

「ライフタイム」を参照してください。

### lifetime (ライフタイム)

オブジェクトが作成されてから破壊されるまでの期間です。有効期限と同義です。

### linked list (連結リスト)

各要素がリストの次の要素への参照を格納している線形データ構造です。

### linked list node (連結リスト ノード)

連結リスト の各要素はノードと呼ばれます。ノードは、リストにあるデータと次のノードへの参照を保持しているコンテナです。

### literal (リテラル)

数字や文字などの Verse プログラミング言語の固定値です。たとえば、1 は 整数 リテラルです。

### local (ローカル)

コード ブロック 内の 定数 や 変数 を指します。これらは作成されたコード ブロックの外部では使用できません。「スコープ」も参照してください。

### locale (ロケール)

プログラミングでは、ロケール はユーザーの言語、地域、およびユーザー インターフェースの他の特徴を定義する一連のパラメータです。Verse では、`locale` は `message` をローカライズする際のコンテキストを設定する型であり、ロケールに基づいてテキストと数値の言語に影響を及ぼします。

### logic (ロジック)

Verse では、ブールロジック値 (`true` と `false`) の 型 として `logic` を使用します。多くの場合、Verse では、フロー制御を判断するために、`logic` 型のステートをテストするのではなく、失敗コンテキストと失敗する可能性がある式とを組み合わせて使用します。

### logic programming (ロジック プログラミング)

ブール ロジック を使って、システム内に存在する問題に関するファクトとルールの表現方法を制御するプログラミング パラダイム です。

### loop (ループ)

`loop` はコード ブロック内で式を繰り返し実行します。`loop` 式では、ユーザーがループを終了するまで永久に繰り返しが行われます (多くの場合、並列処理 プログラミングではこれが許容されます)。次に例を示します。

```Verse
loop:
    Sleep(1.0) # Sleep(1.0) は 1 秒待ってから次の式に進みます。
    Platform.Hide()
    Sleep(1.0) # Sleep(1.0) は 1 秒待ってから次の式に進みます。
    Platform.Show() # ループはすぐに再開され、Sleep(1.0) をもう一度呼び出します。
```

このコード ブロックは、1 秒待つ、プラットフォームを消す、もう 1 秒待つ、プラットフォームを再表示させるという 4 つの式を永久に繰り返します。

ゲーム開発におけるループの使用方法の例については、「ゲームの終了まで繰り返し消えるプラットフォーム」を参照してください。

## M

### map (マップ)

マップは、キー/値のペア と呼ばれる、別の値と関連付けられた値を格納できる コンテナ です。キー/値のペアは、キーの型が 比較可能 な限り、任意の型を組み合わせることができます。マップの要素はマップにキー/値のペアを挿入した順になり、各要素には一意のキーでアクセスできます。「コンテナ型」も参照してください。

### math expression (数式)

Verse の数 式 では、4 つの 演算子 の 1 つを使う式です。このときに使用できる演算子は、`+`、`-`、`*`、または `/` のいずれかです。

### member (メンバー)

Verse のクラス、構造体、インターフェース、モジュールなどの 複合データ構造 の下位区分である、名前付きの 変数 または 関数 です。多くの場合、メンバー変数は フィールド と呼ばれ、メンバー関数は メソッド と呼ばれます。

### message

Verse における `message` は、ロケール に依存しないテキストを含めることのできる 型 です。`message` 変数 を `string` 値 で 初期化 すると、その文字列がメッセージのデフォルトのテキストと言語になります。

### metaverse environment (メタバース環境)

永続的でグローバルに一貫性のある、リアルタイムの 3D 世界です。ユーザーが作成した相互依存の複雑な並列処理コードを実行するランタイム環境であり、数百万人のユーザーが同時に接続します。

### method (メソッド)

メソッドは クラス に関連付けられる 関数 であり、そのクラスの インスタンス のみで呼び出すことができます。

### module (モジュール)

Verse の モジュール は、再配布して利用でき、依存関係 を壊さなくても経時的に進化することが可能なコードのアトミック ユニットです。Verse ファイルにモジュールをインポートすることにより、他の Verse ファイルのコード定義を使用できます。

詳細については、「モジュールとパス」を参照してください。

### mutable (可変)

これは、作成後も変更できるオブジェクトのステートを指します。Verse では、可変にできるのは ポインタ のみです。

不変 と比較してください。

### mutex (ミューテックス)

ミューテックスは、スレッド を 1 つだけ使用する共有リソースへの排他的アクセスを許可する同期 プリミティブ です。「相互排除」も参照してください。

### mutual exclusion (相互排除)

1 つ以上のプロセスがコードの同じセグメントにアクセスする場合、そのセグメントは クリティカル セクション と呼ばれます。相互排除は、2 つのプロセスが同時にクリティカル セクションにアクセスできないようにする方法です。

## N

### NaN

Not a Number (非数) を表す値です。

### native

`native` は、要素の定義の詳細が C++ で実装されていることを示します。この 指定子 は、デベロッパーが後で使用できる C++ の定義を自動生成することが可能です。`native` 指定子は、クラス、インターフェース、列挙型、メソッド、および データ で使用されます。

### native_callable

インスタンス メソッド が ネイティブ であり (C++ で実装されている)、他の C++ コードによって呼び出すことができることを示します。この 指定子 はインスタンス メソッドで使用されていることがわかります。この指定子は サブクラス には反映されないため、この指定子を持つメソッドをオーバーライドする際に、これを定義に加える必要はありません。

### nested (ネスティング)

コードがネスティングされている場合、1 つのコードブロックがより広範な関数を実行する別のコードブロック内に含まれています。

### no-rollback

この エフェクト は、関数の 可変 データの読み取り/書き込みを取り消すことができず、(失敗したときに ロールバック する) 失敗コンテキストで関数を呼び出せないことを示します。

### node (ノード)

「連結リストノード」を参照してください。

## O

### object (オブジェクト)

オブジェクトは クラス の インスタンス です。インスタンスには、そのクラス 型 で定義された同じ動作が含まれますが、実際の 値 が伴います。

「インスタンス」と「オブジェクト」という用語は同義です。

### object-oriented programming (オブジェクト指向プログラミング)

オブジェクト指向プログラミング (OOP) は、クラスとオブジェクトの概念に依存するプログラミング パラダイムです。

### open world language (オープン ワールド言語)

さまざまなユーザーや組織が作成した互いに依存するモジュールが、インターフェースの互換性や永続データの互換性を損なうことなく、明確に定義された細分類ルールに従って経時的に進化できる言語です。

### operand (被演算子)

演算 を実行する数です。たとえば、式 `1 + 2` では `+` が演算子、`1` と `2` の両方が被演算子になります。

### operation (演算)

特定のタスクを達成するためにプログラムで実行されるアクションです。コンピュータの演算には、入力、処理、出力、格納という 4 つの基本グループがあります。演算は 式 の一種です。

### operator (演算子)

アクションや処理を表す記号です。たとえば、`1 + 2` では `+` が演算子です。

### operator precedence (演算子の優先順位)

これは、Verse で 演算子 を組み合わせるときに組み込まれる 評価順 を指します。たとえば、同じ 式 で複数の演算子が使用される場合は、それらの演算子を評価する順番が重要となります。

たとえば、乗算は加算より優先されるため、「`1 + 2 * 3`」は「`3 * 3`」と同じ 評価 になりません。

演算子の優先順位 は、グループ化 式でオーバーライドできます。

### option (オプション)

Verse では、オプションに 型 の値が 1 つ含まれていることもあれば、含まれていないこともあります。

### order of evaluation (評価順)

演算子の優先順位、つまり 式 で特定の 演算 を実行する順番を指します。

### overload (オーバーロード)

関数または演算子をオーバーロードすると、同じ関数名や演算子記号に異なるパラメータを指定できます。たとえば、ある 3D ベクターが `(1,2,3)` のような別の 3D ベクターに等しいと述べる場合、それはきわめて明確ですが、等号演算子を使用して 3D ベクターが `1` のような 1 つの数字に等しいと述べることもあります。この場合、おそらく 3D ベクターは `(1,1,1)` になりますが、オーバーロード部分にはパラメータの異なる複数の「3D Vector =」演算子があり、この言語では、コンテキストを調べてどの演算子を使用するのかを確認する必要があります。

### override (オーバーライド)

Verse では、スーパークラス からフィールドを オーバーライド して初期 値 を割り当てることができます。次に例を示します。

```Verse
tank := class(player_character):
    StartingShields<override> : int = 100
    MaxShields<override> : int = 200
    AllowOvershield<override> : logic = true
    DamageReduction : int = 50

CreateTankPlayerCharacter() : tank =
    return tank{}
```

この `tank` クラスには、デフォルトのクラスの値とは異なる `StartingShields`、`MaxShields`、および `AllowOvershield` の値が含まれます。

また、同じように メソッド の値もオーバーライドできます。

この詳細については、「サブクラス」を参照してください。

## P

### paradigm (パラダイム)

何らかの典型的なパターンやモデルです。プログラミングでは、プログラミング言語の構成がパラダイムになります。プログラミング言語には次の 4 つの主要なパラダイムがあります。

- 命令型
- ロジック
- 関数型
- オブジェクト指向

加えて、Verse のようなマルチパラダイムの言語もあります。

### parallel (同時)

個々のプロセッサなどで、同じ物理時間に実行される複数の演算処理が同時 (並列) 処理です。

### parameter (パラメータ)

型 などの ドメイン を含む入力 変数 と、後で 関数 の 本体 で使用される、関数シグネチャ で定義される任意のデフォルト 値 です。引数 と比較してください。

### parametric type (パラメトリック型)

パラメータ を取得できる 型 です。

### parse (パース)

コンピュータ サイエンスにおいて「パース」するとは、一連のコマンド (通常はプログラム) を処理しやすいコンポーネントに分けること (正しい構文であるかを分析してから、各コンポーネントを定義するタグに関連付けること) を指します。

### parser (パーサー)

コードを パースする ためのプログラムです。

### path (パス)

Verse のパスは、対象を識別するためにグローバル名前空間を使用します。Web ドメインのアイデアと同様です。これらのパスは永続的でユニークなものであり、Verse のプログラマーであれば誰でも検出可能です。

### Perforce

Perforce (P4) は リビジョン コントロール (ソース コード管理またはバージョン管理) を行うソフトウェア ツールで、ソフトウェア コードに対する変更をトラックして管理できます。これは複数のプログラマーが同じプロジェクトで作業を行う場合などに便利です。たとえば、プログラマーがミスをした場合に、バージョン管理によってそのコードの以前のバージョンと比較して、他のプログラマーの作業を中断することなく、その問題を特定して修正することが可能です。

### player (プレイヤー)

人プレイヤーを表す Verse の 型 です。エージェント と比較してください。

### playspace (プレイ空間)

プレイヤーやチームの 配列、または特定のプレイヤーのチームを取得するために使用する Verse API モジュール です。さらに、プレイヤーが追加または削除された イベント を サブスクライブする こともできます。

### pointer (ポインタ)

ポインタは、指定された値の 型 を保持できる 可変 の「ボックス」を参照する方法です。ポインタを使用して、そのボックスの特定の値を変更することができます。値 と比較してください。

### pointer variable (ポインタ変数)

ポインタ 変数 は、値 が格納されるメモリ位置を指し示します。ポインタ変数の作成後にそのポインタ変数のメモリ位置を変更することはできませんが、そのメモリ位置に格納された値を変更することは可能です。

### polling (ポーリング)

ポーリングとは、クライアント プログラムで同期アクティビティとして外部デバイスのステータスをアクティブにサンプリングすることを指します。ポーリングは入出力 (I/O) の面で最も多く使用され、ポーリング I/O やソフトウェア駆動 I/O とも呼ばれます。

### polymorphic (ポリモーフィック)

ポリモーフィック (polymorphic) は、「多」を意味する `poly-` と「形」を意味する `-morph` に由来します。ポリモーフィックな動作は、さまざまな条件下で変数に多様な値を使用できる場合に生じます。

### postfix (ポストフィックス)

1 つだけ 被演算子 があり、演算子が被演算子の後に置かれる 演算子 の形式です。

### precedence (優先順位)

式 で実行する必要がある特定の 演算 の順序です。

### predicate (述語)

Verse では、成功するか 失敗する 部分が述語に該当します。

### preemption (プリエンプション)

後で再開するつもりで実行中のタスクを一時的に中断することを プリエンプション と呼びます。これは通常、タスク内でこのための処理を作成することなく、外部のスケジューラによって行われます。

### prefix (プレフィックス)

1 つだけ 被演算子 があり、演算子が被演算子の前に置かれる 演算子 の形式です。

### primitive type (プリミティブ型)

プリミティブは、別の型から作成されない 型 です。つまり、プリミティブは複合型ではなく、それ以上分解できません。組み込みのプリミティブ型の例としては、`void`、`logic`、`int`、`float`、`rational`、`char` などがあります。プリミティブは Verse 言語に組み込まれます。

コンテナ型 と比較してください。

### program (プログラム)

プログラムは、コンピュータに動作を指示する一連の命令です。プログラムの基本は、コンピュータが入力を受け取って出力を返す方法を示すことにあります。

プログラムは問題を解決しますが、文字どおりに実行されるものであり、悪霊と契約するようなものです。魔神 (プログラム) はきわめて正確にユーザーが要求するものを返します。配慮はありません。エラーが発生するのは、結果に対してプログラマーに思い込みがあって、どのような入力を受け取ってどのような出力になるのかを正確に示していないときです。

### programming (プログラミング)

コンパイル してコンピュータで 実行 できる命令群 (プログラム) を記述する行為です。

### programming language (プログラミング言語)

コンピュータ プログラムを記述するために使用する形式的な言語です。数多くのプログラミング言語があり、それぞれに厳格なルールが設けられています。プログラミング言語の例としては、インタラクティブなストーリー、ゲーム、アニメーションの開発に使用されるビジュアル プログラミング言語の Scratch や、ゲーム開発で使用されることが多いテキストベースの言語である C++ などがあります。Verse は、開発ツールの知識を深めたいと考えているクリエイター向けに Epic Games が開発したプログラミング言語です。

### propagate (反映する)

関数 での反映は、呼び出し元 が 失敗 時に起きることに対処する必要がない場合に行われます。たとえば、decides エフェクト を含む関数は、decides エフェクトを含む別の関数から呼び出すことができますが、この場合、何が呼び出されたとしても、呼び出し元はその後の失敗に対処する必要があります。

### property (プロパティ)

プロパティは、値 を返してそれらの値を公開することを可能にする メンバー (フィールド) です。

### pseudocode (疑似コード)

疑似コード (Pseudocode、発音：SOO-doh-kohd) とは、アルゴリズムが行うべき動作を平易な言語 (プログラミング言語ではない) で詳細に記述したものです。「Pseudo-\_」は真実ではない、本物ではないという意味を持つため、疑似コードはフェイク コードと言えますが、アルゴリズムが何を達成すべきかを調べるには便利です。

疑似コードは大まかな概要と捉えることができます。通常、疑似コードは、実際にコーディングを始める前に、プログラムの大規模または複雑な部分について計画を立てる際に使用されます。

### public member (パブリック メンバー)

別の モジュール に表示される メンバー です。

### pure

入力が同じであれば関数が常にまったく同じ出力を生成し、副次的エフェクトをもたらさない (可変の変数や IO エフェクトなどに書き込む) ことを宣言します。

## Q

### qualify (修飾する)

識別子 を「再利用」できる スコープ 内でその識別子を定義することを指します。たとえば、「cat」という名前の 定数 があり、「sarah.cat」という名前の クラス フィールドに同じ名前を使用することがあります。この場合、どちらにも名前に「cat」が含まれていますが、「sarah.cat」は修飾されています。

### query (クエリ)

クエリ 式 では、演算子 ? を使用して論理または任意値が true であるかどうかをチェックします。

## R

### race

race 式 では、race ブロック のすべての式が同時に実行されますが、1 つの式が完了するとすぐに別の式はキャンセルされ、race 式が制御を再び得ます。race は 構造化並列処理 式です。

### race condition (競合状態)

競合状態は、順番に実行する必要がある演算が正しく実行されるようにするために、プログラムが 2 つ以上の演算を同時に実行しようとしたときに発生します。

### RAII

RAII (Resource Acquisition Is Initialization - リソース取得時に初期化) では、リソースをより効果的に管理する方法として、初期化 と最終化の間のみに存在するリソースを オブジェクト が取得するタイミングを示します。

### raise (発生)

関数 がシグナルを発すると、それによってイベントが発生します。ボタン操作などのイベントが発生すると関係者に通知され、すべてのイベント ハンドラが呼び出されます。

### range expression (範囲式)

範囲 式 には、.. を挟む 2 つの値 (1..5 など) を含む、範囲内のすべての数値が含まれます。範囲式は、for 式などの一部の場所のみで使用できます。

### rational

Verse でサポートされる 3 つの主要な数値 型 の 1 つであり、ほかには int と float があります。rational 型は整数除算の結果のみで使用されます。この値は、値を切り上げるか (Ceil() を使用) 切り下げるか (Floor() を使用) して、整数に変換して戻す必要があります。

### rational number (有理数)

2 つの 整数 を使った既約分数として表現できる数値です。たとえば、「1.75」は「7/4」として表すこともできますが、2 の平方根 (√2) は分数で表現できないため、これは無理数です。無理数の別の例としては円周率 (π) があります。円周率は 3.14159... で始まって無限に続きます。

### recursion (再帰)

再帰とは、関数が自らを 呼び出す ことを指します。

### refactor (リファクタリング)

機能を変えずにコードの構造を変えることです。たとえば、プログラムで何度も繰り返されるコード ブロックはリファクタリングをして、関数呼び出し にすることができます。リファクタリングを行うことで、コードの挙動を変えずに、コードの複雑さを軽減し、コードを読みやすくすることができます。

### REPL

REPL (Read-Evaluate-Print Loop) は、コードを入力し、そのコードを読み取って評価してから結果を確認できるコンピュータ環境です。REPL を使用すれば、何も壊すことなく言語を詳しく調べ、何が機能するのか (またはしないのか) を確認することが可能です。

### result (結果)

式 が実行されて 値 が出力されると、その値が結果です。

### return

プログラムにサブルーチンから離れてリターン アドレスに戻るように指示する 式 です。リターン アドレスは、サブルーチンが呼び出された場所です。

関数 の コード ブロック の最後の式が正しい 値 を生成することに依存するのではなく、return 式を使用して 結果 を明示的に指定することもできます。return 式が実行されると、関数のコード ブロックはすぐに終了します。つまり、他のコードの前に return 式を配置すると後続のコードは実行されません。

### rollback (ロールバック)

プログラムを以前に定義した ステート に戻すことを指します。通常は 失敗した式 からの回復に使用されます。

### routine (ルーチン)

「関数」を参照してください。

### runtime (ランタイム)

ゲーム、シミュレーション、またはアプリケーションの実行に費やされた時間を指します。コンパイルに費やされた時間を指す コンパイル 時間、または開発、コンパイル、デバッグに費やされた時間を指す開発時間と比較してください。

ランタイム時に発生するものと、コンパイル時に発生するものを区別することが一般的となっています。

### rush

rush 式 では、rush ブロック のすべての式が同時に実行されますが、1 つの式が完了するとすぐに rush 式は制御を元に戻し、他の式は個別に実行され続けます。rush は 構造化並列処理 式です。

## S

### scope (スコープ)

スコープ とは、プログラムの中で名前と 値 の関連付けが有効な部分と名前を値の参照に使用できる部分を指します。たとえば、関数内で作成する定数や変数は関数のコンテキスト内のみに存在します。つまり、オブジェクトの ライフタイム は、それらのオブジェクトが作成され、そのコード ブロックの外部では使用できないスコープに限定されます。

### script (スクリプト)

オブジェクト に関連付けられる、独立した Verse の 実行可能 な コード です。

### self variable (self 変数)

Self は、メソッドが 呼び出された クラスの インスタンス を参照するために クラス メソッド で使用できる Verse の特殊な 識別子 です。Self を使用しなくてもメソッドが呼び出されたインスタンスの他のフィールドを参照することはできますが、インスタンス全体を参照しなければならない場合は Self を使用する必要があります。

### semantic error (セマンティック エラー)

「コンパイラ エラー」を参照してください。

### semantics (セマンティクス)

式 の意味です。構文 と比較してください。

### semaphore (セマフォ)

セマフォは ミューテックス のようなものですが、ミューテックスが使用可能なリソースから他の スレッド を締め出すのに対し、セマフォはリソースが使用中であることを知らせるだけという点で異なります。

### sequential execution (順次実行)

コードは通常、式 が現れる順番で 1 行ずつ 実行されます。これは順次実行と呼ばれます。

### set

プログラムの実行中に 変数 の値を変更するために使用できる キーワード です。

構文は `set name = value` です。`set` がキーワード、`name` が変更する変数の名前、`value` が変更後の値です。

| Assignment |               |     |            |
| :--------: | :-----------: | :-: | :--------: |
|    set     | Variable Name |  =  | Expression |
|   `set`    | `PlayerSpeed` | `=` |   `2.0`    |

これは 代入 と呼ばれます。

### shadowing (シャドウイング)

シャドウイングとは、ある 識別子 によって別の識別子が非表示になることを指します。シャドウイングは Verse のエラーであり、これによってコードを コンパイル できなくなります。

### side effect (副次的エフェクト)

副次的エフェクトは、関数 や 式 などのコードによって、その スコープ 外で一部の ステート が変更される場合に生じます。

### signed integer (符号付き整数)

符号付き整数は、正数か負数、または 0 を保持できる値です。左端で + か - を使用してその数が正であるのか負であるのかを示せることから、符号付き整数と呼ばれます。符号なし整数は正数または 0 にしかなりません。

### simulation (シミュレーション)

シミュレーションとは、システムの動作や特徴を別のシステムを使って表現することを指します。これは、Verse では経時的に実行されるコンピュータ プログラムになります。この用語は、シミュレーションの一種である ゲーム という用語よりも幅広いものです。シミュレーションには、ゲームに加えて、インタラクティブ体験、アート、医療および建築向けのビジュアライゼーション、AI、運転/飛行/軍事シミュレータなど、さまざまなものが含まれます。また、シミュレーションは、VR や AR といった媒体でも使用できます。

### simulation update (シミュレーションの更新)

シミュレーションの繰り返される段階やステップ、またはロジック、動作、その他の計算における増分です。この用語は単に 更新 と略されたり、ティック または フレーム と同義で使用されたりします。全般的に、シミュレーションの更新には、定数または変数のいずれかになり得る経過時間が含まれます。この経過時間は デルタタイム とも呼ばれ、実際の時間の流れに一致する場合も、そうでない場合もあります。つまり、シミュレーションの更新は実際の時間よりも速い場合や遅い場合、さらには同じになる場合もあります。

シミュレーションの更新はフレームのレンダリングと 1:1 のステップになる傾向がありますが、Verse ではこれがデフォルトです。ただし、シミュレーションの更新頻度はフレームと多少異なることがあります。たとえば、シミュレートしたオブジェクトの変更点のイテレーションを行っている間に、オンライン ゲームクライアントがサーバーまたは物理システムと非同期になった場合などです。また、シミュレーションが視覚的にまったくレンダリングされないこともあります。

### snippet (スニペット)

「コード スニペット」を参照してください。

### spawn expression (spawn 式)

spawn 式 は async 関数 を開始します。spawn に続く式はすべて、spawn 式の完了を待つことなくすぐに 実行 されます。spawn は、完了するまで独立して継続します。

### specifier (指定子)

指定子は 定義 に追加情報を適用します。たとえば、関数 定義の decides エフェクト指定子は、その関数を 失敗する可能性がある ものとマークします。

指定子は、アクセス指定子 と エフェクト 指定子という 2 つのサブカテゴリに分類されます。

### speculative execution (投機的実行)

Verse では 失敗コンテキスト を利用して、アクションをコミットせずにそれらを試すことができます。これは 投機的実行 と呼ばれます。式 が成功した場合はその式のエフェクトがコミットされます。たとえば、変数の値の変更などがあります。式が失敗すると、式のエフェクトは ロールバック され、式が評価されなかったようになります。

### splat (スプラッティング)

関数の単一要素として タプル を使用すると、関数がタプルの要素のそれぞれで個別に呼び出されるかのようになります。これはタプル展開、またはスプラッティングと呼ばれます。

### standard library (標準ライブラリ)

Verse で使用できる一連の 関数、定数、およびその他の言語の定義です。このライブラリは、一般的なプログラミングのニーズに対応する実装を提供します。プログラマーが頻繁に使用する、数学関数のようなもののリソースです。

### state (ステート)

ステートは オブジェクト の元の 値 に修正を加えたものの組み合わせです。

### statement (文)

結果値を持たないスタンドアローンのコマンドです。Verse は文を使用しません。代わりに 式 を使用します。

### static checking (静的チェック)

コードの セマンティクス に基づいてバグを捕捉できる、コンパイル 中に行われる自動チェックです。

### STM

ソフトウェア トランザクショナル メモリ (STM) は、並列処理プログラミングでの共有メモリへのアクセスを制御する、データベース トランザクションに似た並列処理制御メカニズムです。Verse ではいずれ STM が中心に据えられますが、その最大の理由は大規模分散シミュレーションのパフォーマンスが向上することです。

### string (文字列)

Verse では、文字列は リテラル 型 であり、2 つの引用符間の文字はすべて文字列リテラルです。たとえば、「Hello world」は一般的な文字列です。Verse の文字列には、文字、数字、句読点、スペース、さらには絵文字を含めることができます。

### strongly-typed (強い型付け)

すべての 識別子 に 型 が割り当てられると、プログラミング言語は強い型付けになります。型が明示的に指定されていなければ、その型は推測されます。つまり、そのような識別子の型と演算がそのような型に与える影響がわかるため、言語がランタイム中に予測不可能な結果を出すことはありません。「静的チェック」も参照してください。

### struct (構造体)

struct は structure の省略形であり、いくつかの関連する 変数 をグループ化する方法です。変数はいずれかの 型 になります。

struct は Verse の キーワード です。

### structured concurrency (構造化並列処理)

構造化並列処理とは、特定の並列処理コマンドと async コンテキストのスコープに制約される 有効期限 内の 並列処理 演算を指します。これは、関連する スコープ に制約される、if、for、または return のような構造化 フロー制御 です。

Verse の構造化並列処理式には、sync、race、rush、branch が含まれます。

### subclass (サブクラス)

スーパークラス (親クラス) の メンバー (メソッドとデータ) を 継承 する クラス です。Verse では、新しいメンバーまたは継承した変更済みのメンバーでクラスを拡張することができます。

### subexpression (部分式)

コード ブロック 内に ネスティングされている 式 です。

### submodule (サブモジュール)

別の Verse モジュール内の Verse モジュール です。フォルダとサブフォルダのようなものであり、各サブモジュールはさらに下位に移動するときにパスに新たに /NameOfModule を追加します。

### subroutine (サブルーチン)

頻繁に使用される演算を実行するように設計されたコンピュータ プログラム内の一連の命令です。関数がいくつかの計算を実行して 呼び出し元 に結果を返すという点を除いて、サブルーチンは 関数 と似ています。サブルーチンは、呼び出し元のプログラムに報告することなくジョブを実行します。

### subscribe (サブスクライブする)

サブスクライブは、イベント の 発生 時に 呼び出す 関数 を指定する方法です。これは イベントへのバインディング と呼ばれます。バウンドされた 関数は ハンドラ と呼ばれます。

### subtype (サブタイプ)

その スーパータイプ の全演算をサポートする 型 です。subtype キーワード は 括弧 とともに使用して、特定の型に制約される型を指定できます。たとえば、複数の Verse 配列 メソッド では subtype を使用して、動作するメソッドに対して比較可能なスーパータイプとなるように、配列の全要素を定義できます。

```Verse
(Input:[]t where t:subtype(comparable)).RemoveFirstElement<public>
(ElementToRemove:t)<computes><decides>:[]t
RemoveFirstElement
```

そのため、配列内の各要素は、すべて ElementToRemove 引数と等しいかどうかを判定できるように、comparable のスーパータイプである必要があります。

### succeed (成功)

式 が失敗せずに完了すると、成功したことになります。失敗コンテキスト と比較してください。

### superclass (スーパークラス)

クラス は、継承するクラスのスーパークラスのすべての フィールド を含む、スーパークラス を 継承 できます。このようなクラスは、スーパークラスの サブクラス といわれます。

### supertype (スーパータイプ)

スーパータイプは、少なくとも 1 つの サブタイプ を含む 型 です。スーパータイプがサポートするすべての演算は、すべてのサブタイプでもサポートされている必要があります。Verse では、any が他のあらゆる型の唯一のスーパータイプであり、その他すべての型は any のサブタイプです。comparable 型は、Verse で比較可能なすべての型 (int や float など) のスーパータイプです。

### suspends

関数をキャンセルすることなく一時的に停止 (サスペンド) する エフェクト です。suspends 式 により、async 関数 で完了前に制御を一時停止し、他の並列処理式に協調的に転送できます。

詳細については、「並列処理」を参照してください。

### sync

sync 式 では、sync ブロック のすべての式が 同時に 実行され、sync 式が制御ブロックを生成する前にそれらの式を完了させる必要があります。sync は 構造化並列処理 式です。

### syntax (構文)

プログラミング言語のルールまたは文法です。

セマンティクス と比較してください。

### syntax error (構文エラー)

「コンパイラ エラー」を参照してください。

## T

### tail node (末尾ノード)

連結リスト の最初の ノード を先頭ノード、最後のノードを末尾ノードと呼びます。

### task (タスク)

タスクは、現在 実行中 の async 関数 のステートを表すために使用される オブジェクト です。タスク オブジェクトは、async 関数が一時停止されている場所とその一時停止ポイントの ローカル 変数 の 値 を特定するために使用されます。

### thread (スレッド)

オペレーティング システムで実行できる処理の最小単位です。

### tick (ティック)

ティック (場合によっては フレーム) と同義で使用される「シミュレーションの更新」を参照してください。

### tile (タイル)

床や壁などのサーフェス上のグリッドのセクションです。

### time flow (タイム フロー)

タイム フロー制御は Verse プログラミング言語の中核であり、並列処理 式 によって実現されます。

タイム フローはフロー制御の一種ですが、制御フロー がプログラムの式の順番に基づいてコンピュータで命令が実行される順番に関するものであるのに対して、タイム フローは、並列処理式の使用方法に基づいて、順番ではなく時間で実行を制御します。

タイム フローは、並列処理の別の言い方です。

### top-level expression (トップレベルの式)

トップレベルの式は、コード ブロック内にネスティングされない 式 です。また、ネスティングされている コード ブロック などの複合式の場合もあります。

### transacts

関数 に transacts エフェクト がある場合、それはその関数がデータを読み書きできることを意味しますが、その関数に decides エフェクトもある場合は、それらのアクションを ロールバック できます。このエフェクトは 排他的エフェクト です。

排他的エフェクトが指定されていない関数ではデータの読み取りと書き込みは可能ですが、ロールバックを行うことはできません。

### tuple (タプル)

タプル は、単一の式として扱われる 2 つ以上の 式 です。

タプルの要素はタプルに挿入した順番で配置され、それらの要素には インデックス と呼ばれるタプル内の位置に基づいてアクセスできます。タプル内の式はグループ化されるため、単一の式として扱うことが可能です。

注：「タプル」という単語は、クアドラプル、クインタプル、セクスタプルなどの逆成です。配列 と比較してください。

### type (型)

型は、データに対して実行できる演算とその型のデータ値の格納方法を定義します。整数や文字列などの 共通型、複合型、カスタム型があります。「プリミティブ型」と「コンテナ型」も参照してください。 type キーワード は 中括弧 とともに使用して、想定する型を定義します。関数 宣言 と数値範囲は現時点で宣言としてサポートされています。たとえば、subscribable インターフェースの Subscribe() 関数は、type キーワードを使用して、その Callback パラメータが関数と void 戻り型であることが必要と定義します。

`Subscribe<public>(Callback:type {__(:t):void})<transacts>:cancelable`

### type alias (型エイリアス)

型エイリアスは、既存の 型 の新しい名前を作成する方法です。型エイリアスを 宣言 すると、既存の型ではなくエイリアス名を使用できます。型エイリアスは、新しい型を作成するのではなく、既存の型の新しい名前を提供するだけです。

### type casting (型変換)

構文 NewReference := type_to_cast_to[Reference] を使用して、クラス をそのサブクラスの 1 つに変換できます (型変換 と呼ばれます)。ここで type_to_cast_to は使用する型です。これは 失敗する可能性がある式 です。たとえば、クラスがサブクラスとは異なる型の場合、オブジェクト をその 型 に変換できないと型変換が失敗するためです。

次の例では、型 creative_device_base を持つ TaggedDevice を customizable_light_device 型に変換し、特定の関数を使用できるようにする方法について示しています。TaggedDevice がカスタマイズ可能なライトの仕掛けではない場合、TurnOn() を呼び出しません。

```Verse
if (LightDevice := customizable_light_device[TaggedDevice]):
    LightDevice.TurnOn()
    type checker (型チェッカー)
```

型チェックは、実行 前のプログラムをチェックするために使用されます。これにより、データ型の 値 と 構文 が検証されます。プログラミング言語の 型 システムの主な目的は、型のエラーに起因するプログラムのバグの可能性を減らすことにあります。

## U

### Unicode

言語、プラットフォーム、およびデバイスの文字に関して同等のサポートを提供するために Unicode Consortium が開発した文字エンコーディングの標準です。

### unique

unique 指定子 を クラス に適用すると、それをユニークな (一意の) クラスにすることができます。Verse では、unique クラスの インスタンス を作成するために、結果のインスタンスにユニークな ID をアロケートします。これにより、unique クラスのインスタンスは、その ID を比較するだけで等しいかどうかを判断できます。unique 指定子がないクラスは、そのような ID がなく、等しいかどうかを判断するにはそのフィールドの値を比較する必要があります。つまり、unique クラスは = および <> 演算子で比較でき、comparable 型のサブタイプです。

### unset

値 は割り当てられません。set と比較してください。

### unstructured concurrency (非構造化並列処理)

特定の 並列処理 コマンドや async コンテキスト の スコープ に論理的に制約されない 有効期限 のある並列処理 式 です。この有効期限は、式が 実行 されたスコープを超える可能性があります。goto または assembly jump コマンドなどの非構造化フロー制御に似ています。

### UTF-8

言語、プラットフォーム、およびデバイスの文字に関して同等のサポートを提供するために Unicode Consortium が開発した標準である、Unicode の文字エンコーディングのスキームです。

絵文字 は画像やアイコンのように見えますが、実際にはそうではなく、UTF-8 (Unicode) 文字セットの文字です。

UTF-8 は、世界中のほぼすべての文字と記号をカバーします。

## V

### value (値)

値は、演算のためにプログラムが使用する情報です。値の例としては数値やテキストがあります。

### variable (変数)

プログラムの実行中に変更できる 値 です。変動することがあるため、変数と呼ばれます。

「変数」という用語は、変数と 定数 をまとめて指すこともあります。変数と定数は似ているものの、定数の値はプログラムの実行中に変更できないという大きな違いが 1 つあります。

変数の基本構文は `var name : type = value` です。`var` はこれが変数であることを示す キーワード であり、`name` は変数に割り当てる名前 (識別子) です。`:` は型が次に来ることを示しています。`=` は値が来ることを示しています。続いて値自体を指定します。次に例を示します。

```Verse
PlayerSpeed : float = 2.0
```

これは、プログラムの実行中に変わることがない、2.0 (10 進値) という値が PlayerSpeed に設定されていることを示しています。

| Declaration |               |     |         | Initialization |            |
| :---------: | :-----------: | :-: | :-----: | :------------: | :--------: |
|     var     | Variable Name |  :  |  Type   |       =        | Expression |
|    `var`    | `PlayerSpeed` | `:` | `float` |      `=`       |   `2.0`    |

名前と型は 宣言 であり、値が表現されるところは 初期化 です。変数を 初期化 する際に、その変数に値が割り当てられている必要はありませんが、割り当てておくことがベスト プラクティスです。

変数は、いつでもその値を変更できるという点で定数と異なります。変更は 代入式 を使用して行います。

定数 と比較してください。「`set`」も参照してください。

### varies

この エフェクト は、関数 に対する同じ入力が必ずしも同じ出力を生成するとは限らないということを示します。また `varies` エフェクトは、関数の動作がその関数に 含まれるパッケージ の新しいバージョンで同じになることが保証されないことも示します。

### verbosity (詳細)

ログが生成されたときに表示される追加情報の量を制限する設定です。

### Verse

Verse は、ゲームプレイのプログラミングに重点を置いた、静的にチェックされる プログラミング言語です。

### Verse Explorer

テンプレートから新しい Verse ファイルを作成したり、サブモジュール を使用してファイルを整理したり、ファイル名の変更とファイルの削除をサポートしたりする、Unreal Editor for Fortnite (UEFN) のツールです。

### Verse path (Verse パス)

「パス」を参照してください。

### Verse-authored device (Verse で作成した仕掛け)

Verse を使用して直接プログラミングされた、Unreal Editor for Fortnite (UEFN) で使用する仕掛けです。

### visual programming language (ビジュアル プログラミング言語)

プログラマーがビジュアル要素を使用して (ドラッグして他の要素と接続して) 特定のプログラムの命令を実行する、プログラミング言語の一種です。

### Visual Studio Code

VS Code とも呼ばれる Visual Studio Code は、Microsoft 社が開発した、Windows、Linux、および macOS 用のソースコード エディタです。

### void

Void ではあらゆる 値 を受け取り、False を 返します。これにより、ブロック 内の最後にある 式 の結果の変換を気にせずに、void を返す 関数 の 本体 で暗黙的に値を生成できます。

### VPL

「ビジュアル プログラミング言語」を参照してください。

## W

## X

## Y

## Z

### zero-based numbering (ゼロベースの番号付け)

シーケンスの最初の要素に「1」ではなく「0」を割り当てる番号付けの方法です。つまり、インデックス の「0」の位置が「1」を表し、1 つ目の位置が「2」を表します。「0」から始まるシーケンスの番号付けは、数学的表記では一般的です。プログラミングでは、配列 の最初の位置を「0 番目の位置」と呼ぶことがあります。
